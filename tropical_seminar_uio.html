<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edvard Aksnes</title>
    <link href="styles/style.css" rel="stylesheet">

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
            /*
            // COMMON_CODE_BLOCK_BEGIN
            */
            html {overflow: scroll;}
            strong{font-size: 18px;}
            canvas { z-index: 8; }
            input[type='radio'] {margin-left:0;}
            input[type='checkbox'] {margin-right:7px; margin-left: 0px; padding-left:0px;}
            .group{padding-bottom: 15px;}
            .settings * {z-index: 11; }
            .settings{z-index: 10; font-family: Arial, Helvetica, sans-serif; margin-left: 30px; visibility: hidden; width: 14em; height: 96%; border: solid 1px silver; padding: 2px; overflow-y: scroll; box-sizing: border-box; background-color: white; position: absolute;}
            .indented{margin-left: 20px; margin-top: 10px; padding-bottom: 0px;} 
            .shownObjectsList{overflow: auto; max-width: 150px; max-height: 150px;}
            .showSettingsButton{visibility: visible; z-index: 12; position: absolute }
            .hideSettingsButton{visibility: hidden; z-index: 12; position: absolute; opacity: 0.5}
            button{margin-left: 0; margin-top: 10px}
            img{cursor: pointer;}
            .suboption{padding-top: 15px;}
            #model67606782805 { width: 100%; height: 100%; }
            .threejs_container { width: 80%; height: 300px; margin: 0 auto;}
            input[type=range] {
            -webkit-appearance: none;
            padding:0; 
            width:90%; 
            margin-left: auto;
            margin-right: auto;
            margin-top: 15px;
            margin-bottom: 15px;
            display: block;	
            }
            input[type=range]:focus {
            outline: none;
            }
            input[type=range]::-webkit-slider-runnable-track {
            height: 4px;
            cursor: pointer;
            animate: 0.2s;
            box-shadow: 0px 0px 0px #000000;
            background: #E3E3E3;
            border-radius: 0px;
            border: 0px solid #000000;
            }
            input[type=range]::-webkit-slider-thumb {
            box-shadow: 1px 1px 2px #B8B8B8;
            border: 1px solid #ABABAB;
            height: 13px;
            width: 25px;
            border-radius: 20px;
            background: #E0E0E0;
            cursor: pointer;
            -webkit-appearance: none;
            margin-top: -5px;
            }
            input[type=range]:focus::-webkit-slider-runnable-track {
            background: #E3E3E3;
            }
            input[type=range]::-moz-range-track {
            height: 4px;
            cursor: pointer;
            animate: 0.2s;
            box-shadow: 0px 0px 0px #000000;
            background: #E3E3E3;
            border-radius: 0px;
            border: 0px solid #000000;
            }
            input[type=range]::-moz-range-thumb {
            box-shadow: 1px 1px 2px #B8B8B8;
            border: 1px solid #ABABAB;
            height: 13px;
            width: 25px;
            border-radius: 20px;
            background: #E0E0E0;
            cursor: pointer;
            }
            input[type=range]::-ms-track {
            height: 4px;
            cursor: pointer;
            animate: 0.2s;
            background: transparent;
            border-color: transparent;
            color: transparent;
            }
            input[type=range]::-ms-fill-lower {
            background: #E3E3E3;
            border: 0px solid #000000;
            border-radius: 0px;
            box-shadow: 0px 0px 0px #000000;
            }
            input[type=range]::-ms-fill-upper {
            background: #E3E3E3;
            border: 0px solid #000000;
            border-radius: 0px;
            box-shadow: 0px 0px 0px #000000;
            }
            input[type=range]::-ms-thumb {
            box-shadow: 1px 1px 2px #B8B8B8;
            border: 1px solid #ABABAB;
            height: 13px;
            width: 25px;
            border-radius: 20px;
            background: #E0E0E0;
            cursor: pointer;
            }
            input[type=range]:focus::-ms-fill-lower {
            background: #E3E3E3;
            }
            input[type=range]:focus::-ms-fill-upper {
            background: #E3E3E3;
            }
    </style>
</head>

<body>
    <div class="grid">
        <div class="content">
            <div class="section">
                <h1>UiO Tropical Geometry Learning Seminar</h1>
                <p>This is the webpage for an introductory seminar in tropical geometry. Our ambition is to cover the fundamentals of tropical geometry, a selection of main results and achievements, and some of the most recent developments. The seminar is intended for students, and will include a few exercise sessions. For the more advanced topics of the later sessions, we will invite more experienced participants.</p>

                <div>
                    <div class='threejs_container'>
                            <div id='settings_OUTPUTID' class='settings'>
                                <div class=group id='explode_OUTPUTID'>
                                    <strong>Explode</strong>
                                    <input id='explodeRange_OUTPUTID' type='range' min=0 max=6 step=0.01 value=0>
                                    <div class=indented><input id='explodeCheckbox_OUTPUTID' type='checkbox'>Automatic explosion</div>
                                    <div class=suboption>Exploding speed</div>
                                    <input id='explodingSpeedRange_OUTPUTID' type='range' min=0 max=0.5 step=0.001 value=0.05>
                                </div>
                        
                                <div class=group id='transparency_OUTPUTID' class='transparency'>
                                    <strong>Transparency</strong>
                                    <input id='transparencyRange_OUTPUTID' type='range' min=0 max=1 step=0.01 value=0>
                                </div>
                                
                                <div class=group id='rotation_OUTPUTID'>
                                    <strong>Rotation</strong>
                                    <div class=indented>
                                        <div><input type='checkbox' id='changeRotationX_OUTPUTID'> x-axis</div>
                                        <div><input type='checkbox' id='changeRotationY_OUTPUTID'> y-axis</div>
                                        <div><input type='checkbox' id='changeRotationZ_OUTPUTID'> z-axis</div>
                                        <button id='resetButton_OUTPUTID'>Reset</button>
                                    </div>
                    
                                    <div class=suboption>Rotation speed</div>
                                    <input id='rotationSpeedRange_OUTPUTID' type='range' min=0 max=5 step=0.01 value=2>
                                </div>
                    
                    
                                <div class=group id='display_OUTPUTID'>
                                    <strong>Display</strong>
                                    <div class=indented>
                                        <div id='shownObjectTypesList_OUTPUTID' class='shownObjectsList'></div>
                                    </div>
                                    <div class=suboption>Objects</div>
                                    <div class=indented>
                                    <div id='shownObjectsList_OUTPUTID' class='shownObjectsList'></div>
                                    </div>
                                </div>
                            
                            <div class=group id='camera_OUTPUTID'>
                                <strong>Camera</strong>
                                <div class=indented>
                                <form>
                                    <select id="cameraType_OUTPUTID">
                                        <option value='perspective' selected> Perspective<br></option>
                                        <option value='orthographic' > Orthographic<br></option>
                                    </select>
                                </form>
                                </div>
                            </div>
                    
                                <div class=group id='svg_OUTPUTID'>
                                    <strong>SVG</strong>
                                    <div class=indented>
                                        <form>
                                            <input type="radio" name='screenshotMode' value='download' id='download_OUTPUTID' checked> Download<br>
                                            <input type="radio" name='screenshotMode' value='tab' id='tab_OUTPUTID' > New tab<br>
                                        </form>
                                        <button id='takeScreenshot_OUTPUTID'>Screenshot</button>
                                    </div>
                                </div>
                    
                            </div>	<!-- end of settings -->
                            <img id='hideSettingsButton_OUTPUTID' class='hideSettingsButton' src='js/images/close.svg' width=20px">
                            <img id='showSettingsButton_OUTPUTID' class='showSettingsButton' src='js/images/menu.svg' width=20px">
                    <div id="model67606782805"></div>
                    </div>
                    <script src='js/three.polymake.js'></script>
                    <script>
                    
                    // COMMON_CODE_BLOCK_BEGIN
                    
                    const intervalLength = 25; // for automatic animations
                    const explodableModel = true; 
                    const modelContains = { points: false, pointlabels: false, lines: false, edgelabels: false, faces: false, arrowheads: false };
                    const foldables = [];
                    
                    var three = document.getElementById("model67606782805");
                    var scene = new THREE.Scene();
                    var renderer = new THREE.WebGLRenderer( { antialias: true } );
                    var svgRenderer = new THREE.SVGRenderer( { antialias: true } );
                    renderer.setPixelRatio( window.devicePixelRatio );
                    renderer.setClearColor(0xFFFFFF, 1);
                    svgRenderer.setClearColor(0xFFFFFF, 1);
                    three.appendChild(renderer.domElement);
                    
                    var frustumSize = 4;
                    var cameras = [new THREE.PerspectiveCamera(40, 1, 0.1, 1000), new THREE.OrthographicCamera()];
                    cameras.forEach(function(cam) {
                        cam.position.set(-2, 2, 4);
                        cam.lookAt(0, 0, 0);  
                        cam.up.set(0, 1, 0);         
                    });''
                    var controls = [new THREE.TrackballControls(cameras[0], three), new THREE.OrbitControls(cameras[1], three)];
                    var camera, control;
                    
                    controls[0].zoomSpeed = 0.2;
                    controls[0].rotateSpeed = 4;
                    
                    
                    // class to allow move points together with labels and spheres
                    var PMPoint = function (x,y,z) {
                    this.vector = new THREE.Vector3(x,y,z);
                    this.sprite = null;
                    this.sphere = null;
                    }
                    PMPoint.prototype.addLabel = function(labelsprite) {
                    this.sprite = labelsprite;
                    this.sprite.position.copy(this.vector);
                    }
                    PMPoint.prototype.addSphere = function(spheremesh) {
                    this.sphere = spheremesh;
                    this.sphere.position.copy(this.vector);
                    }
                    PMPoint.prototype.set = function(x,y,z) {
                    this.vector.set(x,y,z);
                    if (this.sprite) {
                        this.sprite.position.copy(this.vector);
                    }
                    if (this.sphere) {
                        this.sphere.position.copy(this.vector);
                    }
                    }
                    PMPoint.prototype.radius = function() {
                    if (this.sphere) {
                        return this.sphere.geometry.parameters.radius;
                    } else {
                        return 0;
                    }
                    };
                    // COMMON_CODE_BLOCK_END
                    var original_op = 0.5;

                    var obj0 = new THREE.Object3D();
                    obj0.name = "unnamed__1";
                    obj0.userData.explodable = 1;
                    obj0.userData.points = [];
                    obj0.userData.points.push(new PMPoint(0, 0, 0));
                    obj0.userData.points.push(new PMPoint(1, 1, 1));
                    obj0.userData.points.push(new PMPoint(-1, 1, 1));
                    obj0.userData.points.push(new PMPoint(-1, 0, 0));
                    
                    obj0.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj0.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj0.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj0.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj0.userData.facets = [[2, 1, 0, 3]];
                    <!-- Facet style -->
                    obj0.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj0);
                    scene.add(obj0);
                    
                    var obj1 = new THREE.Object3D();
                    obj1.name = "unnamed__2";
                    obj1.userData.explodable = 1;
                    obj1.userData.points = [];
                    obj1.userData.points.push(new PMPoint(0, 0, 0));
                    obj1.userData.points.push(new PMPoint(1, 1, 1));
                    obj1.userData.points.push(new PMPoint(1, -1, 1));
                    obj1.userData.points.push(new PMPoint(0, -1, 0));
                    
                    obj1.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj1.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj1.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj1.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj1.userData.facets = [[0, 1, 2, 3]];
                    <!-- Facet style -->
                    obj1.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj1);
                    scene.add(obj1);
                    
                    var obj2 = new THREE.Object3D();
                    obj2.name = "unnamed__3";
                    obj2.userData.explodable = 1;
                    obj2.userData.points = [];
                    obj2.userData.points.push(new PMPoint(1, 1, 1));
                    obj2.userData.points.push(new PMPoint(1, 1, -1));
                    obj2.userData.points.push(new PMPoint(0, 0, -1));
                    obj2.userData.points.push(new PMPoint(0, 0, 0));
                    
                    obj2.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj2.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj2.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj2.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj2.userData.facets = [[2, 1, 0, 3]];
                    <!-- Facet style -->
                    obj2.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj2);
                    scene.add(obj2);
                    
                    var obj3 = new THREE.Object3D();
                    obj3.name = "unnamed__4";
                    obj3.userData.explodable = 1;
                    obj3.userData.points = [];
                    obj3.userData.points.push(new PMPoint(0, -1, 0));
                    obj3.userData.points.push(new PMPoint(0, 0, 0));
                    obj3.userData.points.push(new PMPoint(-1, 0, 0));
                    obj3.userData.points.push(new PMPoint(-1, -1, 0));
                    
                    obj3.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj3.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj3.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj3.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj3.userData.facets = [[2, 1, 0, 3]];
                    <!-- Facet style -->
                    obj3.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj3);
                    scene.add(obj3);
                    
                    var obj4 = new THREE.Object3D();
                    obj4.name = "unnamed__5";
                    obj4.userData.explodable = 1;
                    obj4.userData.points = [];
                    obj4.userData.points.push(new PMPoint(0, 0, -1));
                    obj4.userData.points.push(new PMPoint(0, 0, 0));
                    obj4.userData.points.push(new PMPoint(-1, 0, 0));
                    obj4.userData.points.push(new PMPoint(-1, 0, -1));
                    
                    obj4.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj4.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj4.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj4.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj4.userData.facets = [[2, 1, 0, 3]];
                    <!-- Facet style -->
                    obj4.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj4);
                    scene.add(obj4);
                    
                    var obj5 = new THREE.Object3D();
                    obj5.name = "unnamed__6";
                    obj5.userData.explodable = 1;
                    obj5.userData.points = [];
                    obj5.userData.points.push(new PMPoint(0, 0, -1));
                    obj5.userData.points.push(new PMPoint(0, 0, 0));
                    obj5.userData.points.push(new PMPoint(0, -1, 0));
                    obj5.userData.points.push(new PMPoint(0, -1, -1));
                    
                    obj5.userData.pointradii = 0.002;
                    <!-- Vertex style -->
                    obj5.userData.pointmaterial = new THREE.MeshBasicMaterial( { color: 0xFF0000, side: THREE.DoubleSide, transparent: false } );
                    obj5.userData.edgeindices = [0, 1, 1, 2, 0, 3, 2, 3];
                    <!-- Edge style -->
                    obj5.userData.edgematerial = new THREE.LineBasicMaterial( { color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false } );
                    obj5.userData.facets = [[2, 1, 0, 3]];
                    <!-- Facet style -->
                    obj5.userData.facetmaterial = new THREE.MeshBasicMaterial( { color: 0x77EC9E, depthFunc: THREE.LessDepth, opacity: original_op, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true } );
                    init_object(obj5);
                    scene.add(obj5);
                    
                    // COMMON_CODE_BLOCK_BEGIN
                    function textSpriteMaterial(message, parameters) {
                        if ( parameters === undefined ) parameters = {};
                        var fontface = "Helvetica";
                        var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 15;
                        fontsize = fontsize*10;
                        var lines = message.split('\\n');
                        var size = 512;
                        for(var i = 0; i<lines.length; i++){
                            var tmp = lines[i].length;
                            while(tmp*fontsize > size){
                            fontsize--;
                            }
                        }
                        
                        var canvas = document.createElement('canvas');
                        canvas.width = size;
                        canvas.height = size;
                        var context = canvas.getContext('2d');
                        context.fillStyle = "rgba(255, 255, 255, 0)";
                        context.fill();
                        context.font = fontsize + "px " + fontface;
                        
                        // text color
                        context.fillStyle = "rgba(0, 0, 0, 1.0)";
                        for(var i = 0; i<lines.length; i++){
                            context.fillText(lines[i], size/2, size/2+i*fontsize);
                        }
                        
                        // canvas contents will be used for a texture
                        var texture = new THREE.Texture(canvas);
                        texture.needsUpdate = true;
                        
                        var spriteMaterial = new THREE.SpriteMaterial({map: texture, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
                        return spriteMaterial;
                    }
                    
                    
                    // ---------------------- INITIALIZING OBJECTS--------------------------------------
                    // ---------------------------------------------------------------------------------
                    
                    function init_object(obj) {
                        if (obj.userData.hasOwnProperty("pointmaterial")) {
                            init_points(obj);
                            modelContains.points = true;
                        }
                        if (obj.userData.hasOwnProperty("pointlabels")) {
                            init_pointlabels(obj);
                            modelContains.pointlabels = true;
                        }
                        if (obj.userData.hasOwnProperty("edgematerial")) {
                            init_lines(obj);
                            modelContains.lines = true;
                        }
                        if (obj.userData.hasOwnProperty("edgelabels")) {
                            init_edgelabels(obj);
                            modelContains.edgelabels = true;
                        }
                        if (obj.userData.hasOwnProperty("arrowstyle")) {
                            init_arrowheads(obj);
                            modelContains.arrowheads = true;
                        }
                        if (obj.userData.hasOwnProperty("facetmaterial")) {
                            init_faces(obj);
                            modelContains.faces = true;
                        }
                    }
                    
                    function init_points(obj) {
                        var pointgroup = new THREE.Group();
                        pointgroup.name = "points";
                        var points = obj.userData.points;
                        var radii = obj.userData.pointradii;
                        var materials = obj.userData.pointmaterial;
                        var geometry,material;
                        if (!Array.isArray(radii)) {
                            geometry = new THREE.SphereBufferGeometry(radii);  
                        }
                        if (!Array.isArray(materials)) {
                            material = materials;
                        }
                        for (var i=0; i<points.length; i++) {
                            var point = points[i];
                            if (Array.isArray(radii)) {
                                if (radii[i] == 0) {
                                    continue;
                                }
                                geometry = new THREE.SphereBufferGeometry(radii[i]);  
                            } 
                            if (Array.isArray(materials)) {
                                material = materials[i];     
                            } 
                            var sphere = new THREE.Mesh(geometry, material);
                            point.addSphere(sphere);
                            pointgroup.add(sphere);
                        }
                        obj.add(pointgroup);
                    }
                    
                    function init_pointlabels(obj) {
                        var points = obj.userData.points;
                        var labels = obj.userData.pointlabels;
                        var pointlabels = new THREE.Group();
                        pointlabels.name = "pointlabels";
                        if (Array.isArray(labels)) {
                            for (var i=0; i<points.length; i++) {
                                var point = points[i];
                                var spriteMaterial = textSpriteMaterial( labels[i] );
                                var sprite = new THREE.Sprite(spriteMaterial);
                                point.addLabel(sprite);
                                pointlabels.add(sprite);
                            }
                        } else {
                            var spriteMaterial = textSpriteMaterial( labels );
                            for (var i=0; i<points.length; i++) {
                                var point = points[i];
                                var sprite = new THREE.Sprite(spriteMaterial);
                                point.addLabel(sprite);
                                pointlabels.add(sprite);
                            }
                        }
                        obj.add(pointlabels);
                    }
                    
                    function init_lines(obj) {
                        var edgeindices = obj.userData.edgeindices;
                        var points = obj.userData.points;
                        var materials = obj.userData.edgematerial;
                        var geometry = new THREE.BufferGeometry();
                        var bufarr = new Float32Array( obj.userData.edgeindices.length * 3 );
                        var bufattr = new THREE.Float32BufferAttribute( bufarr, 3 );
                        var geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', bufattr);
                        if (Array.isArray(materials)) {     
                            for (var i=0; i<materials.length; i++) {
                                geometry.addGroup(2*i,2,i);
                            }
                        }
                        var lines = new THREE.LineSegments(geometry, materials);
                        lines.name = "lines";
                        obj.add(lines);
                        updateEdgesPosition(obj);
                    }
                    
                    function init_edgelabels(obj) {
                        var points = obj.userData.points;
                        var edgeindices = obj.userData.edgeindices;
                        var labels = obj.userData.edgelabels;
                        var edgelabels = new THREE.Group();
                        edgelabels.name = "edgelabels";
                        if (Array.isArray(labels)) {
                            for (var i=0; i<edgeindices.length/2; i++) {
                                var spriteMaterial = textSpriteMaterial( labels[i] );
                                var sprite = new THREE.Sprite(spriteMaterial);
                                sprite.position.copy(new THREE.Vector3().addVectors(points[edgeindices[2*i]].vector,points[edgeindices[2*i+1]].vector).multiplyScalar(0.5));
                                edgelabels.add(sprite);
                            }
                        } else {
                            var spriteMaterial = textSpriteMaterial( labels );
                            for (var i=0; i<edgeindices.length/2; i++) {
                                var sprite = new THREE.Sprite(spriteMaterial);
                                sprite.position.copy(new THREE.Vector3().addVectors(points[edgeindices[2*i]].vector,points[edgeindices[2*i+1]].vector).multiplyScalar(0.5));
                                edgelabels.add(sprite);
                            }
                        }
                        obj.add(edgelabels);
                    }
                    
                    function init_arrowheads(obj) {
                        var arrowheads = new THREE.Group();
                        arrowheads.name = "arrowheads";
                        var arrowstyle = obj.userData.arrowstyle;
                        var edgeindices = obj.userData.edgeindices;
                        var edgematerials = obj.userData.edgematerial;
                        var points = obj.userData.points;
                        var material;
                        if (!Array.isArray(edgematerials)) {
                            material = new THREE.MeshBasicMaterial( {color: edgematerials.color} );
                        }
                    
                        for (var i=0; i<edgeindices.length; i=i+2) {
                            var start = points[edgeindices[i]];
                            var end = points[edgeindices[i+1]];
                            var dist = start.vector.distanceTo( end.vector ) - start.radius() - end.radius();
                            if (dist <= 0) {
                                continue;
                            }
                            var dir = new THREE.Vector3().subVectors(end.vector,start.vector);
                            dir.normalize();
                            var axis = new THREE.Vector3().set(dir.z,0,-dir.x);
                            axis.normalize();
                            var radians = Math.acos( dir.y );
                            var radius = dist/25;
                            var height = dist/5;
                            var geometry = new THREE.ConeBufferGeometry(radius,height);
                            var position = new THREE.Vector3().addVectors(start.vector,dir.clone().multiplyScalar(start.radius()+dist-height/2));
                            if (Array.isArray(edgematerials)) {
                                material = new THREE.MeshBasicMaterial( {color: edgematerials[i].color} );
                            }
                            var cone = new THREE.Mesh( geometry, material );
                            cone.quaternion.setFromAxisAngle(axis,radians);;
                            cone.position.copy(position);;
                            arrowheads.add(cone);
                        }
                        obj.add(arrowheads);
                    }
                    
                    function init_faces(obj) {
                        var points = obj.userData.points;
                        var facets = obj.userData.facets;
                        obj.userData.triangleindices = [];
                        for (var i=0; i<facets.length; i++) {
                            facet = facets[i];
                            for (var t=0; t<facet.length-2; t++) {
                                obj.userData.triangleindices.push(facet[0],facet[t+1],facet[t+2]);  
                            }
                        }
                        var bufarr = new Float32Array( obj.userData.triangleindices.length * 3 );
                        var bufattr = new THREE.Float32BufferAttribute(bufarr,3);
                        
                        var materials = obj.userData.facetmaterial;
                        var geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position',bufattr);
                        if (Array.isArray(materials)) {
                            var tricount = 0;
                            var facet;
                            for (var i=0; i<facets.length; i++) {
                                facet = facets[i];
                                geometry.addGroup(tricount,(facet.length-2)*3,i);
                                tricount += (facet.length-2)*3;
                            }
                        }
                        var mesh = new THREE.Mesh(geometry, materials);
                        mesh.name = "faces";
                        obj.add(mesh); 
                        updateFacesPosition(obj);
                    }
                    // //INITIALIZING
                    
                    
                    function updateFacesPosition(obj) {
                        var points = obj.userData.points;
                        var indices = obj.userData.triangleindices;
                        var faces = obj.getObjectByName("faces");
                        var ba = faces.geometry.getAttribute("position");
                        for (var i=0; i<indices.length; i++) {
                            ba.setXYZ(i, points[indices[i]].vector.x, points[indices[i]].vector.y ,points[indices[i]].vector.z); 
                        }
                        faces.geometry.attributes.position.needsUpdate = true;
                        
                    }
                    
                    function updateEdgesPosition(obj) {
                        var points = obj.userData.points;
                        var indices = obj.userData.edgeindices;
                        var lines = obj.getObjectByName("lines");
                        var ba = lines.geometry.getAttribute("position"); 
                        for (var i=0; i<indices.length; i++) {
                            ba.setXYZ(i, points[indices[i]].vector.x, points[indices[i]].vector.y ,points[indices[i]].vector.z); 
                        }
                        lines.geometry.attributes.position.needsUpdate = true;
                    }
                    
                    function onWindowResize() {
                        renderer.setSize( three.clientWidth, three.clientHeight );
                        svgRenderer.setSize( three.clientWidth, three.clientHeight );
                        updateCamera();
                    }
                    
                    function updateCamera() {
                        var width = three.clientWidth;
                        var height = three.clientHeight;
                        var aspect = width / height;
                        if (camera.type == "OrthographicCamera") {
                            camera.left = frustumSize * aspect / - 2;
                            camera.right = frustumSize * aspect / 2;
                            camera.top = frustumSize / 2;
                            camera.bottom = - frustumSize / 2;
                        } else if (camera.type == "PerspectiveCamera") {
                            camera.aspect = aspect;
                        }
                        camera.updateProjectionMatrix();
                    }
                    
                    function changeCamera(event) {
                        var selindex = event.currentTarget.selectedIndex;
                        camera = cameras[selindex];
                        control = controls[selindex];
                        control.enabled = true; 
                        for (var i=0; i<controls.length; i++) {
                            if (i!=selindex) {
                                controls[i].enabled = false;
                            }
                        }
                        updateCamera();
                    }
                    
                    var camtypenode = document.getElementById('cameraType_OUTPUTID');
                    camtypenode.onchange = changeCamera;
                    camtypenode.dispatchEvent(new Event('change'));
                    
                    onWindowResize();
                    window.addEventListener('resize', onWindowResize);	
                    
                    
                    var xRotationEnabled = false;
                    var yRotationEnabled = false;
                    var zRotationEnabled = false;
                    var rotationSpeedFactor = 1;
                    var settingsShown = false;
                    var labelsShown = true;
                    var intervals = [];
                    var timeouts = [];
                    var explodingSpeed = 0.05;
                    var explodeScale = 0;
                    var XMLS = new XMLSerializer();
                    var svgElement;
                    var renderId;
                    
                    var render = function () {
                    
                        renderId = requestAnimationFrame(render);
                    
                    //	comment in for automatic explosion
                    //	explode(updateFactor());
                    
                        var phi = 0.02 * rotationSpeedFactor;
                    
                        if (xRotationEnabled) {
                            scene.rotation.x += phi;
                        }
                        if (yRotationEnabled) {
                            scene.rotation.y += phi;
                        }
                        if (zRotationEnabled) {
                            scene.rotation.z += phi;
                        }
                    
                        control.update();
                        renderer.render(scene, camera);
                    };
                    
                    if ( THREE.WEBGL.isWebGLAvailable() ) {
                        render();
                    } else {
                        var warning = WEBGL.getWebGLErrorMessage();
                        three.appendChild( warning );
                    }
                        
                    function changeTransparency() {
                        var opacity = 1-Number(event.currentTarget.value);
                        for (var i=0; i<scene.children.length; i++) {
                            child = scene.children[i];
                            if ( child.userData.hasOwnProperty("facetmaterial") ) {
                                if (Array.isArray(child.userData.facetmaterial)) {
                                    for (var j=0; j<child.userData.facetmaterial.length; j++) {
                                        child.userData.facetmaterial[j].opacity = opacity;
                                    }
                                } else {
                                    child.userData.facetmaterial.opacity = opacity;
                                }    
                            }
                        }
                    }
                    
                    function changeRotationX(event){
                        xRotationEnabled = event.currentTarget.checked;
                    }	
                    
                    function changeRotationY(event){
                        yRotationEnabled = event.currentTarget.checked;
                    }	
                    
                    function changeRotationZ(event){
                        zRotationEnabled = event.currentTarget.checked;
                    }	
                    
                    
                    function changeRotationSpeedFactor(event){
                        rotationSpeedFactor = Number(event.currentTarget.value);
                    }
                    
                    function resetScene(){
                        scene.rotation.set(0,0,0);
                        camera.position.set(0,0,5);
                        camera.up.set(0,1,0);
                    }
                    
                    function showSettings(event){
                        document.getElementById('settings_OUTPUTID').style.visibility = 'visible';
                        document.getElementById('showSettingsButton_OUTPUTID').style.visibility = 'hidden';
                        document.getElementById('hideSettingsButton_OUTPUTID').style.visibility = 'visible';
                        settingsShown = true;
                    }
                    
                    function hideSettings(event){
                        document.getElementById('settings_OUTPUTID').style.visibility = 'hidden';
                        document.getElementById('showSettingsButton_OUTPUTID').style.visibility = 'visible';
                        document.getElementById('hideSettingsButton_OUTPUTID').style.visibility = 'hidden';
                        settingsShown = false;
                    }
                    
                    
                    
                    var pos = 150* Math.PI;
                    
                    function updateFactor() {
                        pos++;
                        return Math.sin(.01*pos)+1;
                    }
                    
                    // ------------------------ FOLDING ------------------------------------------------
                    // ---------------------------------------------------------------------------------
                    // rotate point p around axis defined by points p1 and p2 by given angle
                    function rotate(p, p1, p2, angle ){   
                        angle = -angle;
                        var x = p.x, y = p.y, z = p.z, 
                        a = p1.x, b = p1.y, c = p1.z, 
                        u = p2.x-p1.x, v = p2.y-p1.y, w = p2.z-p1.z;
                        var result = [];
                        var L = u*u + v*v + w*w;
                        var sqrt = Math.sqrt;
                        var cos = Math.cos;
                        var sin = Math.sin;
                    
                        result[0] = ((a*(v*v+w*w)-u*(b*v+c*w-u*x-v*y-w*z))*(1-cos(angle))+L*x*cos(angle)+sqrt(L)*(-c*v+b*w-w*y+v*z)*sin(angle))/L;
                        result[1] = ((b*(u*u+w*w)-v*(a*u+c*w-u*x-v*y-w*z))*(1-cos(angle))+L*y*cos(angle)+sqrt(L)*(c*u-a*w+w*x-u*z)*sin(angle))/L;
                        result[2] = ((c*(u*u+v*v)-w*(a*u+b*v-u*x-v*y-w*z))*(1-cos(angle))+L*z*cos(angle)+sqrt(L)*(-b*u+a*v-v*x+u*y)*sin(angle))/L;
                    
                        return result;
                    }
                    
                    var fold = function(event){
                        var obj = foldables[Number(event.currentTarget.name)];
                        var foldvalue = Number(event.currentTarget.value);
                        var scale = foldvalue - obj.userData.oldscale;
                    
                        for (var j=0; j<obj.userData.axes.length; j++) {
                            rotateVertices(obj, j, scale);
                        }
                        update(obj);
                        obj.userData.oldscale += scale;
                        lookAtBarycenter(obj);
                    }
                    
                    function lookAtBarycenter(obj){
                        control.target = barycenter(obj);
                    }
                    
                    function barycenter(obj) {
                        var center = new THREE.Vector3(0,0,0);
                        var points = obj.userData.points;
                        for (var i=0; i<points.length; i++){
                            center.add(points[i].vector);
                        }
                        center.divideScalar(points.length);
                        return center;
                    }
                    
                    function rotateVertices(obj, edge, scale) {
                        var axes = obj.userData.axes;
                        var subtrees = obj.userData.subtrees;
                        var points = obj.userData.points;
                        var angles = obj.userData.angles;
                        if (edge < axes.length){
                            for (var j=0; j<subtrees[edge].length; j++){
                                var rotP = rotate(points[subtrees[edge][j]].vector, points[axes[edge][0]].vector,points[axes[edge][1]].vector, scale * (Math.PI - angles[edge]));
                                points[subtrees[edge][j]].set(rotP[0],rotP[1],rotP[2]);
                            }
                        }
                    }
                    
                    function update(obj) {
                    updateFacesPosition(obj);
                    updateEdgesPosition(obj);
                    }
                    
                    if (foldables.length) {
                        var settings = document.getElementById('settings_OUTPUTID');
                        var foldDiv = document.createElement('div');
                        foldDiv.id = 'fold_OUTPUTID';
                        var title = document.createElement('strong');
                        title.innerHTML = 'Fold';
                        foldDiv.appendChild(title);
                        foldDiv.className = 'group';
                        for (var i=0; i<foldables.length; i++) {
                            var range = document.createElement('input');
                            range.type = 'range';
                            range.min = 0;
                            range.max = 1;
                            range.value = 0;
                            range.step = 0.001;
                            range.name = String(i);
                            range.oninput = fold;
                            foldDiv.appendChild(range);
                        }
                        lookAtBarycenter(foldables[0]);
                        settings.insertBefore(foldDiv,settings.childNodes[0]);
                    }
                    
                        
                    // ---------------------- EXPLOSION ------------------------------------------------
                    // ---------------------------------------------------------------------------------
                    
                    if (explodableModel) {
                        for (var i=0; i<scene.children.length; i++) {
                            obj = scene.children[i];
                            if ( obj.userData.explodable ) {
                                computeCentroid(obj);
                            }
                        }
                        document.getElementById('explodeRange_OUTPUTID').oninput = triggerExplode;
                        document.getElementById('explodeCheckbox_OUTPUTID').onchange = triggerAutomaticExplode;
                        document.getElementById('explodingSpeedRange_OUTPUTID').oninput = setExplodingSpeed;
                    }
                    
                    function computeCentroid(obj) {
                        centroid = new THREE.Vector3();
                        obj.userData.points.forEach(function(pmpoint) {
                            centroid.add(pmpoint.vector);			
                        });
                        centroid.divideScalar(obj.userData.points.length);
                        obj.userData.centroid = centroid;
                    }
                    
                    function explode(factor) {
                        for (var i=0; i<scene.children.length; i++) {
                            var obj = scene.children[i];
                            if (obj.userData.hasOwnProperty("centroid")) { 
                                var c = obj.userData.centroid;
                                obj.position.set(c.x*factor, c.y*factor, c.z*factor);
                            }
                        }	
                    }
                    
                    function triggerExplode(event){
                        explodeScale = Number(event.currentTarget.value);
                        explode(explodeScale);
                    }
                    
                    function setExplodingSpeed(event){
                        explodingSpeed = Number(event.currentTarget.value);
                    }
                    
                    function triggerAutomaticExplode(event){
                        if (event.currentTarget.checked){
                            startExploding();
                        } else {
                            clearIntervals();
                        }	
                    }
                    
                    function startExploding(){
                        intervals.push(setInterval(explodingInterval, 25));
                    }
                    
                    
                    function explodingInterval(){
                        explodeScale += explodingSpeed;
                        if (explodeScale <= 6){ 
                            explode(explodeScale);
                        }
                        else{
                            explode(6);
                            explodeScale = 6;
                            clearIntervals();
                            timeouts.push(setTimeout(startUnexploding, 3000));
                        }
                        document.getElementById('explodeRange_OUTPUTID').value = explodeScale;
                    }
                    
                    
                    function startUnexploding(){
                        intervals.push(setInterval(unexplodingInterval, 25));
                    }
                    
                    function unexplodingInterval(){
                        explodeScale -= explodingSpeed;
                        if (explodeScale >= 0){	
                            explode(explodeScale);
                        }
                        else {
                            explode(0);
                            explodeScale = 0;
                            clearIntervals();
                            timeouts.push(setTimeout(startExploding, 3000));
                        }
                        document.getElementById('explodeRange_OUTPUTID').value = explodeScale;
                    }
                    
                    function clearIntervals(){
                        intervals.forEach(function(interval){
                            clearInterval(interval);
                        });
                        intervals = [];
                        timeouts.forEach(function(timeout){
                            clearTimeout(timeout);
                        });
                        timeouts = [];
                    }
                    
                    // ---------------------- DISPLAY --------------------------------------------------
                    // ---------------------------------------------------------------------------------
                    
                    const objectTypeInnerHTMLs = { points: "Points", pointlabels: "Point labels", lines: "Edges", edgelabels: "Edge labels", faces: "Faces", arrowheads: "Arrow heads" };
                    const objectTypeVisible = {};
                    Object.assign(objectTypeVisible,modelContains);
                    const sortedObjectTypeKeys = Object.keys(objectTypeInnerHTMLs).sort();
                    const shownObjectTypesList = document.getElementById('shownObjectTypesList_OUTPUTID');
                    
                    function setVisibility(bool,objname) {
                        for (var i=0; i<scene.children.length; i++){
                            var obj = scene.children[i].getObjectByName(objname);
                            if (obj) {
                                obj.visible = bool;
                            }
                        }
                    }
                    
                    function toggleObjectTypeVisibility(event){
                        var name = event.currentTarget.name;
                        var checked = event.currentTarget.checked;
                        objectTypeVisible[name] = checked;
                        setVisibility(checked,name);
                    }
                    
                    for (var i=0; i<sortedObjectTypeKeys.length; i++){
                        var key = sortedObjectTypeKeys[i];
                        if (modelContains[key]) {
                            var objTypeNode = document.createElement('span');
                            objTypeNode.innerHTML = objectTypeInnerHTMLs[key] + '<br>';
                            var checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = true;
                            checkbox.name = key;
                            checkbox.onchange = toggleObjectTypeVisibility;
                            shownObjectTypesList.appendChild(checkbox);
                            shownObjectTypesList.appendChild(objTypeNode);
                        }
                    }
                    
                    // ------------------------------------------------------
                    
                    function toggleObjectVisibility(event){
                        var nr = Number(event.currentTarget.name);
                        scene.children[nr].visible = event.currentTarget.checked;
                    }
                    
                    // append checkboxes for displaying or hiding objects
                    var shownObjectsList = document.getElementById('shownObjectsList_OUTPUTID');
                    for (var i=0; i<scene.children.length; i++){
                        obj = scene.children[i];
                        var objNode = document.createElement('span');
                        objNode.innerHTML = obj.name + '<br>';
                        var checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = true;
                        checkbox.name = String(i);
                        checkbox.onchange = toggleObjectVisibility;
                        shownObjectsList.appendChild(checkbox);
                        shownObjectsList.appendChild(objNode);
                    }
                    
                    // ---------------------- SVG ------------------------------------------------------
                    // ---------------------------------------------------------------------------------
                    
                    function takeSvgScreenshot() {
                        if (objectTypeVisible["pointlabels"]) {
                            setVisibility(false,"pointlabels");
                        }
                        if (objectTypeVisible["edgelabels"]) {
                            setVisibility(false,"edgelabels");
                        }
                        svgRenderer.render(scene,camera);
                        svgElement = XMLS.serializeToString(svgRenderer.domElement);
                        
                        if (objectTypeVisible["pointlabels"]) {
                            setVisibility(true,"pointlabels");
                        }
                        if (objectTypeVisible["edgelabels"]) {
                            setVisibility(true,"edgelabels");
                        }
                    
                        if (document.getElementById('tab_OUTPUTID').checked){
                            //show in new tab
                            var myWindow = window.open("","");
                            myWindow.document.body.innerHTML = svgElement;
                        } else{
                            // download svg file 
                            download("screenshot.svg", svgElement);
                        }
                    }
                    
                    function download(filename, text) {
                        var element = document.createElement('a');
                        element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                        element.setAttribute('download', filename);
                    
                        element.style.display = 'none';
                        document.body.appendChild(element);
                    
                        element.click();
                    
                        document.body.removeChild(element);
                    }
                    
                    
                    document.getElementById('transparencyRange_OUTPUTID').oninput = changeTransparency;
                    document.getElementById('changeRotationX_OUTPUTID').onchange = changeRotationX;
                    document.getElementById('changeRotationY_OUTPUTID').onchange = changeRotationY;
                    document.getElementById('changeRotationZ_OUTPUTID').onchange = changeRotationZ;
                    document.getElementById('resetButton_OUTPUTID').onclick = resetScene;
                    document.getElementById('rotationSpeedRange_OUTPUTID').oninput = changeRotationSpeedFactor;
                    document.getElementById('takeScreenshot_OUTPUTID').onclick = takeSvgScreenshot;
                    document.getElementById('showSettingsButton_OUTPUTID').onclick = showSettings;
                    document.getElementById('hideSettingsButton_OUTPUTID').onclick = hideSettings;
                    
                    
                    // ------------------ SHORTCUTS --------------------------------------------
                    // -------------------------------------------------------------------------
                    
                    /**
                     * http://www.openjs.com/scripts/events/keyboard_shortcuts/
                     * Version : 2.01.B
                     * By Binny V A
                     * License : BSD
                     */
                    shortcut = {
                        'all_shortcuts':{},//All the shortcuts are stored in this array
                        'add': function(shortcut_combination,callback,opt) {
                            //Provide a set of default options
                            var default_options = {
                                'type':'keydown',
                                'propagate':false,
                                'disable_in_input':false,
                                'target':document,
                                'keycode':false
                            }
                            if(!opt) opt = default_options;
                            else {
                                for(var dfo in default_options) {
                                    if(typeof opt[dfo] == 'undefined') opt[dfo] = default_options[dfo];
                                }
                            }
                    
                            var ele = opt.target;
                            if(typeof opt.target == 'string') ele = document.getElementById(opt.target);
                            var ths = this;
                            shortcut_combination = shortcut_combination.toLowerCase();
                    
                            //The function to be called at keypress
                            var func = function(e) {
                                e = e || window.event;
                                
                                if(opt['disable_in_input']) { //Don't enable shortcut keys in Input, Textarea fields
                                    var element;
                                    if(e.target) element=e.target;
                                    else if(e.srcElement) element=e.srcElement;
                                    if(element.nodeType==3) element=element.parentNode;
                    
                                    if(element.tagName == 'INPUT' || element.tagName == 'TEXTAREA') return;
                                }
                        
                                //Find Which key is pressed
                                if (e.keyCode) code = e.keyCode;
                                else if (e.which) code = e.which;
                                var character = String.fromCharCode(code).toLowerCase();
                                
                                if(code == 188) character=","; //If the user presses , when the type is onkeydown
                                if(code == 190) character="."; //If the user presses , when the type is onkeydown
                    
                                var keys = shortcut_combination.split("+");
                                //Key Pressed - counts the number of valid keypresses - if it is same as the number of keys, the shortcut function is invoked
                                var kp = 0;
                                
                                //Work around for stupid Shift key bug created by using lowercase - as a result the shift+num combination was broken
                                var shift_nums = {
                                    "`":"~",
                                    "1":"!",
                                    "2":"@",
                                    "3":"#",
                                    "4":"$",
                                    "5":"%",
                                    "6":"^",
                                    "7":"&",
                                    "8":"*",
                                    "9":"(",
                                    "0":")",
                                    "-":"_",
                                    "=":"+",
                                    ";":":",
                                    "'":"\"",
                                    ",":"<",
                                    ".":">",
                                    "/":"?",
                                    "\\":"|"
                                }
                                //Special Keys - and their codes
                                var special_keys = {
                                    'esc':27,
                                    'escape':27,
                                    'tab':9,
                                    'space':32,
                                    'return':13,
                                    'enter':13,
                                    'backspace':8,
                        
                                    'scrolllock':145,
                                    'scroll_lock':145,
                                    'scroll':145,
                                    'capslock':20,
                                    'caps_lock':20,
                                    'caps':20,
                                    'numlock':144,
                                    'num_lock':144,
                                    'num':144,
                                    
                                    'pause':19,
                                    'break':19,
                                    
                                    'insert':45,
                                    'home':36,
                                    'delete':46,
                                    'end':35,
                                    
                                    'pageup':33,
                                    'page_up':33,
                                    'pu':33,
                        
                                    'pagedown':34,
                                    'page_down':34,
                                    'pd':34,
                        
                                    'left':37,
                                    'up':38,
                                    'right':39,
                                    'down':40,
                        
                                    'f1':112,
                                    'f2':113,
                                    'f3':114,
                                    'f4':115,
                                    'f5':116,
                                    'f6':117,
                                    'f7':118,
                                    'f8':119,
                                    'f9':120,
                                    'f10':121,
                                    'f11':122,
                                    'f12':123
                                }
                        
                                var modifiers = { 
                                    shift: { wanted:false, pressed:false},
                                    ctrl : { wanted:false, pressed:false},
                                    alt  : { wanted:false, pressed:false},
                                    meta : { wanted:false, pressed:false}	//Meta is Mac specific
                                };
                                            
                                if(e.ctrlKey)	modifiers.ctrl.pressed = true;
                                if(e.shiftKey)	modifiers.shift.pressed = true;
                                if(e.altKey)	modifiers.alt.pressed = true;
                                if(e.metaKey)   modifiers.meta.pressed = true;
                                            
                                for(var i=0; k=keys[i],i<keys.length; i++) {
                                    //Modifiers
                                    if(k == 'ctrl' || k == 'control') {
                                        kp++;
                                        modifiers.ctrl.wanted = true;
                    
                                    } else if(k == 'shift') {
                                        kp++;
                                        modifiers.shift.wanted = true;
                    
                                    } else if(k == 'alt') {
                                        kp++;
                                        modifiers.alt.wanted = true;
                                    } else if(k == 'meta') {
                                        kp++;
                                        modifiers.meta.wanted = true;
                                    } else if(k.length > 1) { //If it is a special key
                                        if(special_keys[k] == code) kp++;
                                        
                                    } else if(opt['keycode']) {
                                        if(opt['keycode'] == code) kp++;
                    
                                    } else { //The special keys did not match
                                        if(character == k) kp++;
                                        else {
                                            if(shift_nums[character] && e.shiftKey) { //Stupid Shift key bug created by using lowercase
                                                character = shift_nums[character]; 
                                                if(character == k) kp++;
                                            }
                                        }
                                    }
                                }
                                
                                if(kp == keys.length && 
                                            modifiers.ctrl.pressed == modifiers.ctrl.wanted &&
                                            modifiers.shift.pressed == modifiers.shift.wanted &&
                                            modifiers.alt.pressed == modifiers.alt.wanted &&
                                            modifiers.meta.pressed == modifiers.meta.wanted) {
                                    callback(e);
                        
                                    if(!opt['propagate']) { //Stop the event
                                        //e.cancelBubble is supported by IE - this will kill the bubbling process.
                                        e.cancelBubble = true;
                                        e.returnValue = false;
                        
                                        //e.stopPropagation works in Firefox.
                                        if (e.stopPropagation) {
                                            e.stopPropagation();
                                            e.preventDefault();
                                        }
                                        return false;
                                    }
                                }
                            }
                            this.all_shortcuts[shortcut_combination] = {
                                'callback':func, 
                                'target':ele, 
                                'event': opt['type']
                            };
                            //Attach the function with the event
                            if(ele.addEventListener) ele.addEventListener(opt['type'], func, false);
                            else if(ele.attachEvent) ele.attachEvent('on'+opt['type'], func);
                            else ele['on'+opt['type']] = func;
                        },
                    
                        //Remove the shortcut - just specify the shortcut and I will remove the binding
                        'remove':function(shortcut_combination) {
                            shortcut_combination = shortcut_combination.toLowerCase();
                            var binding = this.all_shortcuts[shortcut_combination];
                            delete(this.all_shortcuts[shortcut_combination])
                            if(!binding) return;
                            var type = binding['event'];
                            var ele = binding['target'];
                            var callback = binding['callback'];
                    
                            if(ele.detachEvent) ele.detachEvent('on'+type, callback);
                            else if(ele.removeEventListener) ele.removeEventListener(type, callback, false);
                            else ele['on'+type] = false;
                        }
                    }
                    
                    shortcut.add("Alt+Left",function() {
                        var event = new Event('click');
                        if (settingsShown){
                            document.getElementById('hideSettingsButton_OUTPUTID').dispatchEvent(event);
                        } else {
                            document.getElementById('showSettingsButton_OUTPUTID').dispatchEvent(event);
                        }
                    });
                    
                    
                    // COMMON_CODE_BLOCK_END
                        </script>
                </div>
                <p></p>
                <p style="margin: 0 auto; width: 80%; text-align: center; font-size: larger;"><b>Rotate me!</b></p>
                <p></p>
            </div>
            <div class="section">
                <h2>Practical information:</h2>
                <ul>
                    <li>Meeting times: Tuesdays at 14:15, 2 hours max</li>
                    <li>Room: Zoom for the moment.</li>
                    <li>Contact: 
                        <ul>
                            <li>Edvard Aksnes (edvardak at math dot uio dot no),</li>
                            <li>Simen Westbye Moe (swm418 at ic dot ac dot uk),</li>
                            <li>Kris Shaw (krisshaw at math dot uio dot no).</li></li>
                        </ul>
                </ul>
            </div>

            <div class="section">
                <h2>Talks</h2>
                <table>
                    <tr>
                        <p>Session 0 (external): <b>Tropical homology and Hodge theory</b></p>
                        <p>Date: 23-27 August 2021</p>
                        Our seminar series will be kicked off by attending the <a href="https://sites.google.com/view/tropicalhomologyandhodgetheory">Tropical homology and Hodge theory</a> seminar which is being held in Leuven. The ambition for our seminar series will be to understand some of the topics discussed here.
                    </tr>
                    <tr></tr>
                    <tr>
                        <p>Session 1: <b>Tropical Arithmetic, curves and hypersurfaces</b></p>
                        <p>Date: Tuesday 31 August 2021, Time: 14.15, Speaker: Edvard Aksnes</p>
                        We will introduce tropical geometry through <i>tropical arithmetic</i>, define what a <i>tropical polynomial</i>. Then we will look at <i>tropical curves</i> and <i>tropical hypersurfaces</i>, both intrinsically and through the lens of <i>tropicalization</i>. We build up to the theorem of Kapranov. The format is: 45 min talk + 15 min break + 45 min exercise session.
                    </tr>
                    <tr></tr>
                    <tr>
                        <p>Session 2: <b>Tropical intersection theory</b></p>
                        <p>Date: Tuesday 7 September 2021, Time: 14.15, Speaker: ?</p>
                        Detailed description is comming.
                        The format is: 45 min talk + 15 min break + 45 min exercise session.
                    </tr>
                    <tr>
                        <p>Session 3: <b>Tropicalization: valuations and Maslov dequantization</b></p>
                        <p>Date: Tuesday 14 September 2021, Time: 14.15, Speaker: ?</p>
                        <!-- The format is: 45 min talk + 15 min break + 45 min exercise session. -->
                    </tr>
                    <tr>
                        <p>Session 4: <b>Tropical linear spaces and matroids</b></p>
                        <p>Date: Tuesday 21 September 2021, Time: 14.15, Speaker: ?</p>
                        <!-- The format is: 45 min talk + 15 min break + 45 min exercise session. -->
                    </tr>
                    <tr>
                        <p>Session 5+: <b>To be determined...</b></p>
                        <p>Date: ?, Time: ?, Speaker: ?</p>
                    </tr>
                </ul>
                <p></p>
            </div>
            <div class="section"></div>
            <div class="section">
                <h2>Topics:</h2>
                <ul>
                    <li>
                        <p>General introduction:</p>
                        <ul>
                            <li>What are tropical varieties?</li>
                            <li>How to construct tropical varities? (Tropicalization (in a torus?), Valuations, Log limit, combinatorics (Bergman fan, and more?), etc?)</li>
                            <li>How are these constructions related?</li>
                            <li>History of tropical geometry?</li>
                        </ul>
                    </li>
                    <li>
                        <p>What are the main results in tropical geometry?</p>
                        <ul>
                            <li>Fundamental theorems of tropical geometry?</li>
                            <li>Are logaritmic limits and valuations the same thing? Especially wrt. the "Fundamental theorem" in Maclagan Sturmfels. Is this Maslov dequantization?</li>
                            <li>Tropical geometry over other valued fields?</li>
                            <li>Why are Bergman fans of matroids the tropical linear spaces? </li>
                            <li>What are tropical divisors/line bundles?</li>
                            <li>Algebraic cycles vs tropical cycles? Reconstruction theorems? Recovery in chow groups. Relation to Hodge theory?</li><p>
                            <li>What is tropical homology/cohomology? Where does it come from? What can it compute in AlgGeo? In combinatorics?</li>
                            <li>What is tropical Hodge theory?</li>
                            <li>Tropical schemes/tropical ideals? How is the semiring approach formulated?</li>
                        </ul>
                    </li>
                    <li>
                        <p>Topics in tropical geometry:</p>
                        <ul>
                            <li>Polytopes &amp; fans, Legendre transform.</li>
                            <li>Toric degenerations?</li>
                            <li>Tropical modification?</li>
                            <li>Tropical manifolds/piecewise linear structures? Abstract tropical variety?</li>
                            <li>What are tropical compactifications? How do we compactify in tropical geometry? What can we read of from the boundary?</li>
                            <li>Moduli spaces and curve counting?</li>
                            <li>Patchworking</li>
                            <li>Tropical Riemann Roch? </li>
                        </ul>
                    </li>
                    <li>
                        <p>Tropical geometry in relation to other subjects:</p>
                        <ul>
                            <li>Tropical geometry vs Berkovich geometry? Skeletons vs tropical stuff?</li>
                            <li>What does mirror symmerty have to do with tropical geometry? </li>
                            <li>What does log geometry have to do with tropical geometry?</li>
                            <li>Applications to complex geometry?</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</body>

</html>