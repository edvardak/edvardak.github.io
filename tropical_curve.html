<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edvard Aksnes</title>
    <link href="styles/style.css" rel="stylesheet">
 
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <style>
       html {
          overflow: scroll;
       }
 
       strong {
          font-size: 18px;
       }
 
       canvas {
          z-index: 8;
       }
 
       input[type='radio'] {
          margin-left: 0;
       }
 
       input[type='checkbox'] {
          margin-right: 7px;
          margin-left: 0px;
          padding-left: 0px;
       }
 
       .group {
          padding-bottom: 15px;
       }
 
       .settings * {
          z-index: 11;
       }
 
       .settings {
          z-index: 10;
          font-family: Arial, Helvetica, sans-serif;
          margin-left: 30px;
          visibility: hidden;
          width: 14em;
          height: 96%;
          border: solid 1px silver;
          padding: 2px;
          overflow-y: scroll;
          box-sizing: border-box;
          background-color: white;
          position: absolute;
       }
 
       .indented {
          margin-left: 20px;
          margin-top: 10px;
          padding-bottom: 0px;
       }
 
       .shownObjectsList {
          overflow: auto;
          max-width: 150px;
          max-height: 150px;
       }
 
       .showSettingsButton {
          visibility: visible;
          z-index: 12;
          position: absolute
       }
 
       .hideSettingsButton {
          visibility: hidden;
          z-index: 12;
          position: absolute;
          opacity: 0.5
       }
 
       button {
          margin-left: 0;
          margin-top: 10px
       }
 
       img {
          cursor: pointer;
       }
 
       .suboption {
          padding-top: 15px;
       }
 
       #model32396045871 {
          width: 100%;
          height: 100%;
       }
 
       .threejs_container {
          width: 100%;
          height: 600px;
       }
 
       input[type=range] {
          -webkit-appearance: none;
          padding: 0;
          width: 90%;
          margin-left: auto;
          margin-right: auto;
          margin-top: 15px;
          margin-bottom: 15px;
          display: block;
       }
 
       input[type=range]:focus {
          outline: none;
       }
 
       input[type=range]::-webkit-slider-runnable-track {
          height: 4px;
          cursor: pointer;
          /* animate: 0.2s; */
          box-shadow: 0px 0px 0px #000000;
          background: #E3E3E3;
          border-radius: 0px;
          border: 0px solid #000000;
       }
 
       input[type=range]::-webkit-slider-thumb {
          box-shadow: 1px 1px 2px #B8B8B8;
          border: 1px solid #ABABAB;
          height: 13px;
          width: 25px;
          border-radius: 20px;
          background: #E0E0E0;
          cursor: pointer;
          -webkit-appearance: none;
          margin-top: -5px;
       }
 
       input[type=range]:focus::-webkit-slider-runnable-track {
          background: #E3E3E3;
       }
 
       input[type=range]::-moz-range-track {
          height: 4px;
          cursor: pointer;
          /* animate: 0.2s; */
          box-shadow: 0px 0px 0px #000000;
          background: #E3E3E3;
          border-radius: 0px;
          border: 0px solid #000000;
       }
 
       input[type=range]::-moz-range-thumb {
          box-shadow: 1px 1px 2px #B8B8B8;
          border: 1px solid #ABABAB;
          height: 13px;
          width: 25px;
          border-radius: 20px;
          background: #E0E0E0;
          cursor: pointer;
       }
 
       input[type=range]::-ms-track {
          height: 4px;
          cursor: pointer;
          /* animate: 0.2s; */
          background: transparent;
          border-color: transparent;
          color: transparent;
       }
 
       input[type=range]::-ms-fill-lower {
          background: #E3E3E3;
          border: 0px solid #000000;
          border-radius: 0px;
          box-shadow: 0px 0px 0px #000000;
       }
 
       input[type=range]::-ms-fill-upper {
          background: #E3E3E3;
          border: 0px solid #000000;
          border-radius: 0px;
          box-shadow: 0px 0px 0px #000000;
       }
 
       input[type=range]::-ms-thumb {
          box-shadow: 1px 1px 2px #B8B8B8;
          border: 1px solid #ABABAB;
          height: 13px;
          width: 25px;
          border-radius: 20px;
          background: #E0E0E0;
          cursor: pointer;
       }
 
       input[type=range]:focus::-ms-fill-lower {
          background: #E3E3E3;
       }
 
       input[type=range]:focus::-ms-fill-upper {
          background: #E3E3E3;
       }
    </style>
</head>
<body>
    <form id="polynomial">
        <label for="expression">Polynomial in tropical form (no spaces):</label><br>
        <input type="text" id="polynomial_expression" name="poly" value="x^2+y+0">
    </form>
    <div>
        <div class='threejs_container'>
           <div id='settings_OUTPUTID' class='settings'>
              <div class=group id='explode_OUTPUTID'>
                 <strong>Explode</strong>
                 <input id='explodeRange_OUTPUTID' type='range' min=0 max=6 step=0.01 value=0>
                 <div class=indented><input id='explodeCheckbox_OUTPUTID' type='checkbox'>Automatic explosion
                 </div>
                 <div class=suboption>Exploding speed</div>
                 <input id='explodingSpeedRange_OUTPUTID' type='range' min=0 max=0.5 step=0.001 value=0.05>
              </div>

              <div class=group id='transparency_OUTPUTID' class='transparency'>
                 <strong>Transparency</strong>
                 <input id='transparencyRange_OUTPUTID' type='range' min=0 max=1 step=0.01 value=0>
              </div>

              <div class=group id='rotation_OUTPUTID'>
                 <strong>Rotation</strong>
                 <div class=indented>
                    <div><input type='checkbox' id='changeRotationX_OUTPUTID'> x-axis</div>
                    <div><input type='checkbox' id='changeRotationY_OUTPUTID'> y-axis</div>
                    <div><input type='checkbox' id='changeRotationZ_OUTPUTID'> z-axis</div>
                    <button id='resetButton_OUTPUTID'>Reset</button>
                 </div>

                 <div class=suboption>Rotation speed</div>
                 <input id='rotationSpeedRange_OUTPUTID' type='range' min=0 max=5 step=0.01 value=2>
              </div>


              <div class=group id='display_OUTPUTID'>
                 <strong>Display</strong>
                 <div class=indented>
                    <div id='shownObjectTypesList_OUTPUTID' class='shownObjectsList'></div>
                 </div>
                 <div class=suboption>Objects</div>
                 <div class=indented>
                    <div id='shownObjectsList_OUTPUTID' class='shownObjectsList'></div>
                 </div>
              </div>

              <div class=group id='camera_OUTPUTID'>
                 <strong>Camera</strong>
                 <div class=indented>
                    <form>
                       <select id="cameraType_OUTPUTID">
                          <option value='perspective' selected> Perspective<br></option>
                          <option value='orthographic'> Orthographic<br></option>
                       </select>
                    </form>
                 </div>
              </div>

              <div class=group id='svg_OUTPUTID'>
                 <strong>SVG</strong>
                 <div class=indented>
                    <form>
                       <input type="radio" name='screenshotMode' value='download' id='download_OUTPUTID' checked>
                       Download<br>
                       <input type="radio" name='screenshotMode' value='tab' id='tab_OUTPUTID'> New tab<br>
                    </form>
                    <button id='takeScreenshot_OUTPUTID'>Screenshot</button>
                 </div>
              </div>

           </div> <!-- End of settings -->
           <img id='hideSettingsButton_OUTPUTID' class='hideSettingsButton' src='js/images/close.svg'
              width=20px">
           <img id='showSettingsButton_OUTPUTID' class='showSettingsButton' src='js/images/menu.svg' width=20px">
           <div id="model32396045871"></div>
        </div>
        <script src='js/three.polymake.js'></script>
        <script>
            var x = document.getElementById("polynomial_expression");
            var raw_string = x.value;
            terms_string = raw_string.split("+");
            console.log(terms_string);
            terms_string = terms_string.map(text => text.replace('\^','*'));
            console.log(terms_string);


           // COMMON_CODE_BLOCK_BEGIN

           const intervalLength = 25; // for automatic animations
           const explodableModel = true;
           const modelContains = { points: false, pointlabels: false, lines: false, edgelabels: false, faces: false, arrowheads: false };
           const foldables = [];

           var three = document.getElementById("model32396045871");
           var scene = new THREE.Scene();
           var renderer = new THREE.WebGLRenderer({ antialias: true });
           var svgRenderer = new THREE.SVGRenderer({ antialias: true });
           renderer.setPixelRatio(window.devicePixelRatio);
           renderer.setClearColor(0xFFFFFF, 1);
           svgRenderer.setClearColor(0xFFFFFF, 1);
           three.appendChild(renderer.domElement);

           var frustumSize = 4;
           var cameras = [new THREE.PerspectiveCamera(75, 1, 0.1, 1000), new THREE.OrthographicCamera()];
           cameras.forEach(function (cam) {
              cam.position.set(7, 5, 20);
              cam.lookAt(0, 0, 0);
              cam.up.set(0, 1, 0);
           });
           var controls = [new THREE.TrackballControls(cameras[0], three), new THREE.OrbitControls(cameras[1], three)];
           var camera, control;

           controls[0].zoomSpeed = 0.2;
           controls[0].rotateSpeed = 4;
           for (let i = 0; i < controls.length; i++) {
              controls[i].target = new THREE.Vector3(3, 3, 3);
           }

           // class to allow move points together with labels and spheres
           var PMPoint = function (x, y, z) {
              this.vector = new THREE.Vector3(x, y, z);
              this.sprite = null;
              this.sphere = null;
           }
           PMPoint.prototype.addLabel = function (labelsprite) {
              this.sprite = labelsprite;
              this.sprite.position.copy(this.vector);
           }
           PMPoint.prototype.addSphere = function (spheremesh) {
              this.sphere = spheremesh;
              this.sphere.position.copy(this.vector);
           }
           PMPoint.prototype.set = function (x, y, z) {
              this.vector.set(x, y, z);
              if (this.sprite) {
                 this.sprite.position.copy(this.vector);
              }
              if (this.sphere) {
                 this.sphere.position.copy(this.vector);
              }
           }
           PMPoint.prototype.radius = function () {
              if (this.sphere) {
                 return this.sphere.geometry.parameters.radius;
              } else {
                 return 0;
              }
           };

           
           // COMMON_CODE_BLOCK_END
           var opacity_default = 0.5;

           var obj0 = new THREE.Object3D();
           obj0.name = "unnamed__1";
           obj0.userData.explodable = 1;
           obj0.userData.points = [];
           obj0.userData.points.push(new PMPoint(0, 0, -3));
           obj0.userData.points.push(new PMPoint(0, 0, -1));
           obj0.userData.points.push(new PMPoint(-1, 0, 0));
           obj0.userData.points.push(new PMPoint(-3, 0, 0));
           obj0.userData.points.push(new PMPoint(-3, 0, -3));

           obj0.userData.pointradii = 0.002;
           // Vertex style -->
           obj0.userData.pointmaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000, side: THREE.DoubleSide, transparent: false });
           obj0.userData.edgeindices = [0, 1, 1, 2, 2, 3, 0, 4, 3, 4];
           // Edge style -->
           obj0.userData.edgematerial = new THREE.LineBasicMaterial({ color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false });
           obj0.userData.facets = [[3, 2, 1, 0, 4]];
           // Facet style -->
           obj0.userData.facetmaterial = new THREE.MeshBasicMaterial({ color: 0x235370, depthFunc: THREE.LessDepth, opacity: opacity_default, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true });
           init_object(obj0);
           scene.add(obj0);

        //    var obj1 = new THREE.Object3D();
        //    obj1.name = "unnamed__2";
        //    obj1.userData.explodable = 1;
        //    obj1.userData.points = [];
        //    obj1.userData.points.push(new PMPoint(0, 0, -3));
        //    obj1.userData.points.push(new PMPoint(0, 0, -1));
        //    obj1.userData.points.push(new PMPoint(0, -1, 0));
        //    obj1.userData.points.push(new PMPoint(0, -3, 0));
        //    obj1.userData.points.push(new PMPoint(0, -3, -3));

        //    obj1.userData.pointradii = 0.002;
        //    // Vertex style -->
        //    obj1.userData.pointmaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000, side: THREE.DoubleSide, transparent: false });
        //    obj1.userData.edgeindices = [0, 1, 1, 2, 2, 3, 0, 4, 3, 4];
        //    // Edge style -->
        //    obj1.userData.edgematerial = new THREE.LineBasicMaterial({ color: 0x000000, depthTest: true, linewidth: 1.5, transparent: false });
        //    obj1.userData.facets = [[3, 2, 1, 0, 4]];
        //    // Facet style -->
        //    obj1.userData.facetmaterial = new THREE.MeshBasicMaterial({ color: 0x235370, depthFunc: THREE.LessDepth, opacity: opacity_default, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 0.5, side: THREE.DoubleSide, transparent: true });
        //    init_object(obj1);
        //    scene.add(obj1);

           

           // COMMON_CODE_BLOCK_BEGIN
           function textSpriteMaterial(message, parameters) {
              if (parameters === undefined) parameters = {};
              var fontface = "Helvetica";
              var fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 15;
              fontsize = fontsize * 10;
              var lines = message.split('\\n');
              var size = 512;
              for (var i = 0; i < lines.length; i++) {
                 var tmp = lines[i].length;
                 while (tmp * fontsize > size) {
                    fontsize--;
                 }
              }

              var canvas = document.createElement('canvas');
              canvas.width = size;
              canvas.height = size;
              var context = canvas.getContext('2d');
              context.fillStyle = "rgba(255, 255, 255, 0)";
              context.fill();
              context.font = fontsize + "px " + fontface;

              // text color
              context.fillStyle = "rgba(0, 0, 0, 1.0)";
              for (var i = 0; i < lines.length; i++) {
                 context.fillText(lines[i], size / 2, size / 2 + i * fontsize);
              }

              // canvas contents will be used for a texture
              var texture = new THREE.Texture(canvas);
              texture.needsUpdate = true;

              var spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: true, depthWrite: false, polygonOffset: true, polygonOffsetFactor: -1, polygonOffsetUnits: 1 });
              return spriteMaterial;
           }


           // ---------------------- INITIALIZING OBJECTS--------------------------------------
           // ---------------------------------------------------------------------------------

           function init_object(obj) {
              if (obj.userData.hasOwnProperty("pointmaterial")) {
                 init_points(obj);
                 modelContains.points = true;
              }
              if (obj.userData.hasOwnProperty("pointlabels")) {
                 init_pointlabels(obj);
                 modelContains.pointlabels = true;
              }
              if (obj.userData.hasOwnProperty("edgematerial")) {
                 init_lines(obj);
                 modelContains.lines = true;
              }
              if (obj.userData.hasOwnProperty("edgelabels")) {
                 init_edgelabels(obj);
                 modelContains.edgelabels = true;
              }
              if (obj.userData.hasOwnProperty("arrowstyle")) {
                 init_arrowheads(obj);
                 modelContains.arrowheads = true;
              }
              if (obj.userData.hasOwnProperty("facetmaterial")) {
                 init_faces(obj);
                 modelContains.faces = true;
              }
           }

           function init_points(obj) {
              var pointgroup = new THREE.Group();
              pointgroup.name = "points";
              var points = obj.userData.points;
              var radii = obj.userData.pointradii;
              var materials = obj.userData.pointmaterial;
              var geometry, material;
              if (!Array.isArray(radii)) {
                 geometry = new THREE.SphereBufferGeometry(radii);
              }
              if (!Array.isArray(materials)) {
                 material = materials;
              }
              for (var i = 0; i < points.length; i++) {
                 var point = points[i];
                 if (Array.isArray(radii)) {
                    if (radii[i] == 0) {
                       continue;
                    }
                    geometry = new THREE.SphereBufferGeometry(radii[i]);
                 }
                 if (Array.isArray(materials)) {
                    material = materials[i];
                 }
                 var sphere = new THREE.Mesh(geometry, material);
                 point.addSphere(sphere);
                 pointgroup.add(sphere);
              }
              obj.add(pointgroup);
           }

           function init_pointlabels(obj) {
              var points = obj.userData.points;
              var labels = obj.userData.pointlabels;
              var pointlabels = new THREE.Group();
              pointlabels.name = "pointlabels";
              if (Array.isArray(labels)) {
                 for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    var spriteMaterial = textSpriteMaterial(labels[i]);
                    var sprite = new THREE.Sprite(spriteMaterial);
                    point.addLabel(sprite);
                    pointlabels.add(sprite);
                 }
              } else {
                 var spriteMaterial = textSpriteMaterial(labels);
                 for (var i = 0; i < points.length; i++) {
                    var point = points[i];
                    var sprite = new THREE.Sprite(spriteMaterial);
                    point.addLabel(sprite);
                    pointlabels.add(sprite);
                 }
              }
              obj.add(pointlabels);
           }

           function init_lines(obj) {
              var edgeindices = obj.userData.edgeindices;
              var points = obj.userData.points;
              var materials = obj.userData.edgematerial;
              var geometry = new THREE.BufferGeometry();
              var bufarr = new Float32Array(obj.userData.edgeindices.length * 3);
              var bufattr = new THREE.Float32BufferAttribute(bufarr, 3);
              var geometry = new THREE.BufferGeometry();
              geometry.setAttribute('position', bufattr);
              if (Array.isArray(materials)) {
                 for (var i = 0; i < materials.length; i++) {
                    geometry.addGroup(2 * i, 2, i);
                 }
              }
              var lines = new THREE.LineSegments(geometry, materials);
              lines.name = "lines";
              obj.add(lines);
              updateEdgesPosition(obj);
           }

           function init_edgelabels(obj) {
              var points = obj.userData.points;
              var edgeindices = obj.userData.edgeindices;
              var labels = obj.userData.edgelabels;
              var edgelabels = new THREE.Group();
              edgelabels.name = "edgelabels";
              if (Array.isArray(labels)) {
                 for (var i = 0; i < edgeindices.length / 2; i++) {
                    var spriteMaterial = textSpriteMaterial(labels[i]);
                    var sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(new THREE.Vector3().addVectors(points[edgeindices[2 * i]].vector, points[edgeindices[2 * i + 1]].vector).multiplyScalar(0.5));
                    edgelabels.add(sprite);
                 }
              } else {
                 var spriteMaterial = textSpriteMaterial(labels);
                 for (var i = 0; i < edgeindices.length / 2; i++) {
                    var sprite = new THREE.Sprite(spriteMaterial);
                    sprite.position.copy(new THREE.Vector3().addVectors(points[edgeindices[2 * i]].vector, points[edgeindices[2 * i + 1]].vector).multiplyScalar(0.5));
                    edgelabels.add(sprite);
                 }
              }
              obj.add(edgelabels);
           }

           function init_arrowheads(obj) {
              var arrowheads = new THREE.Group();
              arrowheads.name = "arrowheads";
              var arrowstyle = obj.userData.arrowstyle;
              var edgeindices = obj.userData.edgeindices;
              var edgematerials = obj.userData.edgematerial;
              var points = obj.userData.points;
              var material;
              if (!Array.isArray(edgematerials)) {
                 material = new THREE.MeshBasicMaterial({ color: edgematerials.color });
              }

              for (var i = 0; i < edgeindices.length; i = i + 2) {
                 var start = points[edgeindices[i]];
                 var end = points[edgeindices[i + 1]];
                 var dist = start.vector.distanceTo(end.vector) - start.radius() - end.radius();
                 if (dist <= 0) {
                    continue;
                 }
                 var dir = new THREE.Vector3().subVectors(end.vector, start.vector);
                 dir.normalize();
                 var axis = new THREE.Vector3().set(dir.z, 0, -dir.x);
                 axis.normalize();
                 var radians = Math.acos(dir.y);
                 var radius = dist / 25;
                 var height = dist / 5;
                 var geometry = new THREE.ConeBufferGeometry(radius, height);
                 var position = new THREE.Vector3().addVectors(start.vector, dir.clone().multiplyScalar(start.radius() + dist - height / 2));
                 if (Array.isArray(edgematerials)) {
                    material = new THREE.MeshBasicMaterial({ color: edgematerials[i].color });
                 }
                 var cone = new THREE.Mesh(geometry, material);
                 cone.quaternion.setFromAxisAngle(axis, radians);;
                 cone.position.copy(position);;
                 arrowheads.add(cone);
              }
              obj.add(arrowheads);
           }

           function init_faces(obj) {
              var points = obj.userData.points;
              var facets = obj.userData.facets;
              obj.userData.triangleindices = [];
              for (var i = 0; i < facets.length; i++) {
                 facet = facets[i];
                 for (var t = 0; t < facet.length - 2; t++) {
                    obj.userData.triangleindices.push(facet[0], facet[t + 1], facet[t + 2]);
                 }
              }
              var bufarr = new Float32Array(obj.userData.triangleindices.length * 3);
              var bufattr = new THREE.Float32BufferAttribute(bufarr, 3);

              var materials = obj.userData.facetmaterial;
              var geometry = new THREE.BufferGeometry();
              geometry.setAttribute('position', bufattr);
              if (Array.isArray(materials)) {
                 var tricount = 0;
                 var facet;
                 for (var i = 0; i < facets.length; i++) {
                    facet = facets[i];
                    geometry.addGroup(tricount, (facet.length - 2) * 3, i);
                    tricount += (facet.length - 2) * 3;
                 }
              }
              var mesh = new THREE.Mesh(geometry, materials);
              mesh.name = "faces";
              obj.add(mesh);
              updateFacesPosition(obj);
           }
           // //INITIALIZING


           function updateFacesPosition(obj) {
              var points = obj.userData.points;
              var indices = obj.userData.triangleindices;
              var faces = obj.getObjectByName("faces");
              var ba = faces.geometry.getAttribute("position");
              for (var i = 0; i < indices.length; i++) {
                 ba.setXYZ(i, points[indices[i]].vector.x, points[indices[i]].vector.y, points[indices[i]].vector.z);
              }
              faces.geometry.attributes.position.needsUpdate = true;

           }

           function updateEdgesPosition(obj) {
              var points = obj.userData.points;
              var indices = obj.userData.edgeindices;
              var lines = obj.getObjectByName("lines");
              var ba = lines.geometry.getAttribute("position");
              for (var i = 0; i < indices.length; i++) {
                 ba.setXYZ(i, points[indices[i]].vector.x, points[indices[i]].vector.y, points[indices[i]].vector.z);
              }
              lines.geometry.attributes.position.needsUpdate = true;
           }

           function onWindowResize() {
              renderer.setSize(three.clientWidth, three.clientHeight);
              svgRenderer.setSize(three.clientWidth, three.clientHeight);
              updateCamera();
           }

           function updateCamera() {
              var width = three.clientWidth;
              var height = three.clientHeight;
              var aspect = width / height;
              if (camera.type == "OrthographicCamera") {
                 camera.left = frustumSize * aspect / - 2;
                 camera.right = frustumSize * aspect / 2;
                 camera.top = frustumSize / 2;
                 camera.bottom = - frustumSize / 2;
              } else if (camera.type == "PerspectiveCamera") {
                 camera.aspect = aspect;
              }
              camera.updateProjectionMatrix();
           }

           function changeCamera(event) {
              var selindex = event.currentTarget.selectedIndex;
              camera = cameras[selindex];
              control = controls[selindex];
              control.enabled = true;
              for (var i = 0; i < controls.length; i++) {
                 if (i != selindex) {
                    controls[i].enabled = false;
                 }
              }
              updateCamera();
           }

           var camtypenode = document.getElementById('cameraType_OUTPUTID');
           camtypenode.onchange = changeCamera;
           camtypenode.dispatchEvent(new Event('change'));

           onWindowResize();
           window.addEventListener('resize', onWindowResize);


           var xRotationEnabled = false;
           var yRotationEnabled = false;
           var zRotationEnabled = false;
           var rotationSpeedFactor = 1;
           var settingsShown = false;
           var labelsShown = true;
           var intervals = [];
           var timeouts = [];
           var explodingSpeed = 0.05;
           var explodeScale = 0;
           var XMLS = new XMLSerializer();
           var svgElement;
           var renderId;

           var render = function () {

              renderId = requestAnimationFrame(render);

              //	comment in for automatic explosion
              //	explode(updateFactor());

              var phi = 0.02 * rotationSpeedFactor;

              if (xRotationEnabled) {
                 scene.rotation.x += phi;
              }
              if (yRotationEnabled) {
                 scene.rotation.y += phi;
              }
              if (zRotationEnabled) {
                 scene.rotation.z += phi;
              }

              control.update();
              renderer.render(scene, camera);
           };

           if (THREE.WEBGL.isWebGLAvailable()) {
              render();
           } else {
              var warning = WEBGL.getWebGLErrorMessage();
              three.appendChild(warning);
           }

           function changeTransparency() {
              var opacity = 1 - Number(event.currentTarget.value);
              for (var i = 0; i < scene.children.length; i++) {
                 child = scene.children[i];
                 if (child.userData.hasOwnProperty("facetmaterial")) {
                    if (Array.isArray(child.userData.facetmaterial)) {
                       for (var j = 0; j < child.userData.facetmaterial.length; j++) {
                          child.userData.facetmaterial[j].opacity = opacity;
                       }
                    } else {
                       child.userData.facetmaterial.opacity = opacity;
                    }
                 }
              }
           }

           function changeRotationX(event) {
              xRotationEnabled = event.currentTarget.checked;
           }

           function changeRotationY(event) {
              yRotationEnabled = event.currentTarget.checked;
           }

           function changeRotationZ(event) {
              zRotationEnabled = event.currentTarget.checked;
           }


           function changeRotationSpeedFactor(event) {
              rotationSpeedFactor = Number(event.currentTarget.value);
           }

           function resetScene() {
              scene.rotation.set(0, 0, 0);
              camera.position.set(0, 0, 5);
              camera.up.set(0, 1, 0);
           }

           function showSettings(event) {
              document.getElementById('settings_OUTPUTID').style.visibility = 'visible';
              document.getElementById('showSettingsButton_OUTPUTID').style.visibility = 'hidden';
              document.getElementById('hideSettingsButton_OUTPUTID').style.visibility = 'visible';
              settingsShown = true;
           }

           function hideSettings(event) {
              document.getElementById('settings_OUTPUTID').style.visibility = 'hidden';
              document.getElementById('showSettingsButton_OUTPUTID').style.visibility = 'visible';
              document.getElementById('hideSettingsButton_OUTPUTID').style.visibility = 'hidden';
              settingsShown = false;
           }



           var pos = 150 * Math.PI;

           function updateFactor() {
              pos++;
              return Math.sin(.01 * pos) + 1;
           }

           // ------------------------ FOLDING ------------------------------------------------
           // ---------------------------------------------------------------------------------
           // rotate point p around axis defined by points p1 and p2 by given angle
           function rotate(p, p1, p2, angle) {
              angle = -angle;
              var x = p.x, y = p.y, z = p.z,
                 a = p1.x, b = p1.y, c = p1.z,
                 u = p2.x - p1.x, v = p2.y - p1.y, w = p2.z - p1.z;
              var result = [];
              var L = u * u + v * v + w * w;
              var sqrt = Math.sqrt;
              var cos = Math.cos;
              var sin = Math.sin;

              result[0] = ((a * (v * v + w * w) - u * (b * v + c * w - u * x - v * y - w * z)) * (1 - cos(angle)) + L * x * cos(angle) + sqrt(L) * (-c * v + b * w - w * y + v * z) * sin(angle)) / L;
              result[1] = ((b * (u * u + w * w) - v * (a * u + c * w - u * x - v * y - w * z)) * (1 - cos(angle)) + L * y * cos(angle) + sqrt(L) * (c * u - a * w + w * x - u * z) * sin(angle)) / L;
              result[2] = ((c * (u * u + v * v) - w * (a * u + b * v - u * x - v * y - w * z)) * (1 - cos(angle)) + L * z * cos(angle) + sqrt(L) * (-b * u + a * v - v * x + u * y) * sin(angle)) / L;

              return result;
           }

           var fold = function (event) {
              var obj = foldables[Number(event.currentTarget.name)];
              var foldvalue = Number(event.currentTarget.value);
              var scale = foldvalue - obj.userData.oldscale;

              for (var j = 0; j < obj.userData.axes.length; j++) {
                 rotateVertices(obj, j, scale);
              }
              update(obj);
              obj.userData.oldscale += scale;
              lookAtBarycenter(obj);
           }

           function lookAtBarycenter(obj) {
              control.target = barycenter(obj);
           }

           function barycenter(obj) {
              var center = new THREE.Vector3(0, 0, 0);
              var points = obj.userData.points;
              for (var i = 0; i < points.length; i++) {
                 center.add(points[i].vector);
              }
              center.divideScalar(points.length);
              return center;
           }

           function rotateVertices(obj, edge, scale) {
              var axes = obj.userData.axes;
              var subtrees = obj.userData.subtrees;
              var points = obj.userData.points;
              var angles = obj.userData.angles;
              if (edge < axes.length) {
                 for (var j = 0; j < subtrees[edge].length; j++) {
                    var rotP = rotate(points[subtrees[edge][j]].vector, points[axes[edge][0]].vector, points[axes[edge][1]].vector, scale * (Math.PI - angles[edge]));
                    points[subtrees[edge][j]].set(rotP[0], rotP[1], rotP[2]);
                 }
              }
           }

           function update(obj) {
              updateFacesPosition(obj);
              updateEdgesPosition(obj);
           }

           if (foldables.length) {
              var settings = document.getElementById('settings_OUTPUTID');
              var foldDiv = document.createElement('div');
              foldDiv.id = 'fold_OUTPUTID';
              var title = document.createElement('strong');
              title.innerHTML = 'Fold';
              foldDiv.appendChild(title);
              foldDiv.className = 'group';
              for (var i = 0; i < foldables.length; i++) {
                 var range = document.createElement('input');
                 range.type = 'range';
                 range.min = 0;
                 range.max = 1;
                 range.value = 0;
                 range.step = 0.001;
                 range.name = String(i);
                 range.oninput = fold;
                 foldDiv.appendChild(range);
              }
              lookAtBarycenter(foldables[0]);
              settings.insertBefore(foldDiv, settings.childNodes[0]);
           }


           // ---------------------- EXPLOSION ------------------------------------------------
           // ---------------------------------------------------------------------------------

           if (explodableModel) {
              for (var i = 0; i < scene.children.length; i++) {
                 obj = scene.children[i];
                 if (obj.userData.explodable) {
                    computeCentroid(obj);
                 }
              }
              document.getElementById('explodeRange_OUTPUTID').oninput = triggerExplode;
              document.getElementById('explodeCheckbox_OUTPUTID').onchange = triggerAutomaticExplode;
              document.getElementById('explodingSpeedRange_OUTPUTID').oninput = setExplodingSpeed;
           }

           function computeCentroid(obj) {
              centroid = new THREE.Vector3();
              obj.userData.points.forEach(function (pmpoint) {
                 centroid.add(pmpoint.vector);
              });
              centroid.divideScalar(obj.userData.points.length);
              obj.userData.centroid = centroid;
           }

           function explode(factor) {
              for (var i = 0; i < scene.children.length; i++) {
                 var obj = scene.children[i];
                 if (obj.userData.hasOwnProperty("centroid")) {
                    var c = obj.userData.centroid;
                    obj.position.set(c.x * factor, c.y * factor, c.z * factor);
                 }
              }
           }

           function triggerExplode(event) {
              explodeScale = Number(event.currentTarget.value);
              explode(explodeScale);
           }

           function setExplodingSpeed(event) {
              explodingSpeed = Number(event.currentTarget.value);
           }

           function triggerAutomaticExplode(event) {
              if (event.currentTarget.checked) {
                 startExploding();
              } else {
                 clearIntervals();
              }
           }

           function startExploding() {
              intervals.push(setInterval(explodingInterval, 25));
           }


           function explodingInterval() {
              explodeScale += explodingSpeed;
              if (explodeScale <= 6) {
                 explode(explodeScale);
              }
              else {
                 explode(6);
                 explodeScale = 6;
                 clearIntervals();
                 timeouts.push(setTimeout(startUnexploding, 3000));
              }
              document.getElementById('explodeRange_OUTPUTID').value = explodeScale;
           }


           function startUnexploding() {
              intervals.push(setInterval(unexplodingInterval, 25));
           }

           function unexplodingInterval() {
              explodeScale -= explodingSpeed;
              if (explodeScale >= 0) {
                 explode(explodeScale);
              }
              else {
                 explode(0);
                 explodeScale = 0;
                 clearIntervals();
                 timeouts.push(setTimeout(startExploding, 3000));
              }
              document.getElementById('explodeRange_OUTPUTID').value = explodeScale;
           }

           function clearIntervals() {
              intervals.forEach(function (interval) {
                 clearInterval(interval);
              });
              intervals = [];
              timeouts.forEach(function (timeout) {
                 clearTimeout(timeout);
              });
              timeouts = [];
           }

           // ---------------------- DISPLAY --------------------------------------------------
           // ---------------------------------------------------------------------------------

           const objectTypeInnerHTMLs = { points: "Points", pointlabels: "Point labels", lines: "Edges", edgelabels: "Edge labels", faces: "Faces", arrowheads: "Arrow heads" };
           const objectTypeVisible = {};
           Object.assign(objectTypeVisible, modelContains);
           const sortedObjectTypeKeys = Object.keys(objectTypeInnerHTMLs).sort();
           const shownObjectTypesList = document.getElementById('shownObjectTypesList_OUTPUTID');

           function setVisibility(bool, objname) {
              for (var i = 0; i < scene.children.length; i++) {
                 var obj = scene.children[i].getObjectByName(objname);
                 if (obj) {
                    obj.visible = bool;
                 }
              }
           }

           function toggleObjectTypeVisibility(event) {
              var name = event.currentTarget.name;
              var checked = event.currentTarget.checked;
              objectTypeVisible[name] = checked;
              setVisibility(checked, name);
           }

           for (var i = 0; i < sortedObjectTypeKeys.length; i++) {
              var key = sortedObjectTypeKeys[i];
              if (modelContains[key]) {
                 var objTypeNode = document.createElement('span');
                 objTypeNode.innerHTML = objectTypeInnerHTMLs[key] + '<br>';
                 var checkbox = document.createElement('input');
                 checkbox.type = 'checkbox';
                 checkbox.checked = true;
                 checkbox.name = key;
                 checkbox.onchange = toggleObjectTypeVisibility;
                 shownObjectTypesList.appendChild(checkbox);
                 shownObjectTypesList.appendChild(objTypeNode);
              }
           }

           // ------------------------------------------------------

           function toggleObjectVisibility(event) {
              var nr = Number(event.currentTarget.name);
              scene.children[nr].visible = event.currentTarget.checked;
           }

           // append checkboxes for displaying or hiding objects
           var shownObjectsList = document.getElementById('shownObjectsList_OUTPUTID');
           for (var i = 0; i < scene.children.length; i++) {
              obj = scene.children[i];
              var objNode = document.createElement('span');
              objNode.innerHTML = obj.name + '<br>';
              var checkbox = document.createElement('input');
              checkbox.type = 'checkbox';
              checkbox.checked = true;
              checkbox.name = String(i);
              checkbox.onchange = toggleObjectVisibility;
              shownObjectsList.appendChild(checkbox);
              shownObjectsList.appendChild(objNode);
           }

           // ---------------------- SVG ------------------------------------------------------
           // ---------------------------------------------------------------------------------

           function takeSvgScreenshot() {
              if (objectTypeVisible["pointlabels"]) {
                 setVisibility(false, "pointlabels");
              }
              if (objectTypeVisible["edgelabels"]) {
                 setVisibility(false, "edgelabels");
              }
              svgRenderer.render(scene, camera);
              svgElement = XMLS.serializeToString(svgRenderer.domElement);

              if (objectTypeVisible["pointlabels"]) {
                 setVisibility(true, "pointlabels");
              }
              if (objectTypeVisible["edgelabels"]) {
                 setVisibility(true, "edgelabels");
              }

              if (document.getElementById('tab_OUTPUTID').checked) {
                 //show in new tab
                 var myWindow = window.open("", "");
                 myWindow.document.body.innerHTML = svgElement;
              } else {
                 // download svg file 
                 download("screenshot.svg", svgElement);
              }
           }

           function download(filename, text) {
              var element = document.createElement('a');
              element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
              element.setAttribute('download', filename);

              element.style.display = 'none';
              document.body.appendChild(element);

              element.click();

              document.body.removeChild(element);
           }


           document.getElementById('transparencyRange_OUTPUTID').oninput = changeTransparency;
           document.getElementById('changeRotationX_OUTPUTID').onchange = changeRotationX;
           document.getElementById('changeRotationY_OUTPUTID').onchange = changeRotationY;
           document.getElementById('changeRotationZ_OUTPUTID').onchange = changeRotationZ;
           document.getElementById('resetButton_OUTPUTID').onclick = resetScene;
           document.getElementById('rotationSpeedRange_OUTPUTID').oninput = changeRotationSpeedFactor;
           document.getElementById('takeScreenshot_OUTPUTID').onclick = takeSvgScreenshot;
           document.getElementById('showSettingsButton_OUTPUTID').onclick = showSettings;
           document.getElementById('hideSettingsButton_OUTPUTID').onclick = hideSettings;

         // COMMON_CODE_BLOCK_END
        </script>
     </div>
     <p></p>
     <p style="margin: 0 auto; width: 80%; text-align: center; font-size: larger;"><b>Rotate me!</b></p>
     <p></p>
</body>
</html>